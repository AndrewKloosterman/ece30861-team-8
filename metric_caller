import multiprocessing
import re
import os
import importlib
import shutil
import hashlib # Used in demo function

def load_available_functions(directory: str, script_verbosity: int = 1) -> dict:
    # This function remains the same as before
    functions = {}
    if script_verbosity > 0:
        print(f"üîç Discovering functions in './{directory}/'...")
    for filename in os.listdir(directory):
        if filename.endswith('.py') and not filename.startswith('__'):
            module_name = filename[:-3]
            try:
                module = importlib.import_module(f"{directory}.{module_name}")
                func = getattr(module, module_name)
                functions[module_name] = func
                if script_verbosity > 0:
                    print(f"  - Loaded function: '{module_name}'")
            except (ImportError, AttributeError) as e:
                if script_verbosity > 0:
                    print(f"  - ‚ö†Ô∏è  Could not load '{module_name}': {e}")
    return functions

def process_worker(target_func, result_queue, weight, *args):
    """
    A wrapper function that executes the target, gets its float result,
    and puts the result and its weight into the shared queue.
    """
    result = target_func(*args)
    result_queue.put((float(result), float(weight)))

def run_concurrently_from_file(filename: str, available_functions: dict, script_verbosity: int = 1):
    """
    Parses a file, executes functions concurrently, and calculates a weighted compound score.
    """
    # Regex now captures a function, string arg, int verbosity, and a final float/int weight.
    line_pattern = re.compile(r'(\w+)\("([^"]*)",\s*(\d+)\)\s*([\d.]+)')
    
    processes = []
    results_queue = multiprocessing.Queue()

    if script_verbosity > 0:
        print(f"\nReading and parsing tasks from '{filename}'...")
    
    try:
        with open(filename, 'r', encoding="utf-8") as f:
            for i, line in enumerate(f, 1):
                line = line.strip()
                if not line: continue

                match = line_pattern.match(line)
                if match:
                    func_name, argument, verbosity_str, weight_str = match.groups()
                    if func_name in available_functions:
                        target_func = available_functions[func_name]
                        verbosity_level = int(verbosity_str)
                        weight = float(weight_str)

                        # The target is now our worker, which calls the actual function
                        process = multiprocessing.Process(
                            target=process_worker,
                            args=(target_func, results_queue, weight, argument, verbosity_level)
                        )
                        processes.append(process)
                        if script_verbosity > 0:
                            print(f'  - Queued: {func_name}(...) with weight {weight}')
                    elif script_verbosity > 0:
                        print(f"  - ‚ö†Ô∏è  Warning: Func '{func_name}' on line {i} not available. Skipping.")
                elif script_verbosity > 0:
                    print(f"  - ‚ö†Ô∏è  Warning: Could not parse line {i}: '{line}'. Skipping.")
    except FileNotFoundError:
        if script_verbosity > 0: print(f"  - üõë Error: File '{filename}' not found.")
        return None, []

    if not processes:
        if script_verbosity > 0: print("No valid tasks to run.")
        return 0.0, []

    # Start all processes
    if script_verbosity > 0: print("\n--- Starting all processes ---")
    for p in processes: p.start()

    # Retrieve results from the queue
    if script_verbosity > 0: print("--- Collecting results ---")
    individual_scores = []
    compound_score = 0.0
    for _ in range(len(processes)):
        score, weight = results_queue.get() # Blocks until a result is available
        individual_scores.append(score)
        compound_score += score * weight

    # Wait for all processes to finish completely
    for p in processes: p.join()

    if script_verbosity > 0: print("\n--- All processes have completed ---")
    return compound_score, individual_scores

if __name__ == "__main__":
    # --- 1. SETUP ---
    functions_dir = "functions"
    os.makedirs(functions_dir, exist_ok=True)
    with open(os.path.join(functions_dir, "__init__.py"), "w", encoding="utf-8") as f: pass
    with open(os.path.join(functions_dir, "process_data.py"), "w", encoding="utf-8") as f:
        f.write("import os, time, hashlib\n")
        f.write("def process_data(data: str, verbosity: int) -> float:\n")
        f.write("    pid = os.getpid()\n")
        f.write("    if verbosity > 0: print(f'üöÄ [Process ID: {pid}] Processing data: \\'{data}\\'')\n")
        f.write("    time.sleep(1)\n")
        f.write("    hash_object = hashlib.md5(data.encode())\n")
        f.write("    score = int(hash_object.hexdigest(), 16) % 1000 / 10.0\n")
        f.write("    if verbosity > 0: print(f'‚úÖ [Process ID: {pid}] Finished processing. Score: {score}')\n")
        f.write("    return score\n")
    with open(os.path.join(functions_dir, "log_message.py"), "w", encoding="utf-8") as f:
        f.write("import os, time\n")
        f.write("def log_message(message: str, verbosity: int) -> float:\n")
        f.write("    pid = os.getpid()\n")
        f.write("    if verbosity > 0: print(f'üìù [Process ID: {pid}] Logging message: \\'{message}\\'')\n")
        f.write("    time.sleep(0.5)\n")
        f.write("    score = float(len(message))\n")
        f.write("    if verbosity > 0: print(f'üëç [Process ID: {pid}] Message logged. Score: {score}')\n")
        f.write("    return score\n")

    tasks_filename = "tasks.txt"
    with open(tasks_filename, "w", encoding="utf-8") as f:
        f.write('process_data("Analyze system performance", 1) 1.5\n')
        f.write('log_message("User login successful", 1) 0.5\n')
        f.write('process_data("Generate weekly report", 1) 2.0\n')

    # --- 2. EXECUTION ---
    AVAILABLE_FUNCTIONS = load_available_functions(functions_dir)
    final_score, all_scores = run_concurrently_from_file(tasks_filename, AVAILABLE_FUNCTIONS)
    
    print("\n" + "="*40)
    print("           FINAL RESULTS")
    print("="*40)
    print(f"Individual Scores: {all_scores}")
    print(f"Compound Score:    {final_score:.2f}")
    print("="*40)

    # --- 3. CLEANUP ---
    # os.remove(tasks_filename)
    # shutil.rmtree(functions_dir)